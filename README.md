# Поиск и группировка объектов на графах
## Функции 
* Построение графа - graph_structure.py
* Вспомогательные функции для вычислений - Auxiliary_functions.py
* Поиск лучших групп(клик) - search.py

## Исследование

<p> Изначальное время выполнения программы составляло ~27 минут, было выдвинуто предположение, что это проблема библиотеки networkx, которая написана на чистом python.
Была попробована библиотека graph_tool, в ходе написания было выясненно, что в graph_tool отсутствуют многие методы упрощающие работу с графами. 
Так например поиск сообществ клик. Также разницы в скорости выполнения не было. Оказалось, долгое выполнение кода следствие использования питоновских циклов и pandas для работы с большим объемом данных. </p>

<p> Первым делом была добавленна параллельность (joblib.Parallel) для обработки каждой клики. Это сократило время выполнения с ~27 минут до 8 минут. </p>

<p> Далее был изменен подход к формированию результирующего датафрейма. Изначально все клики были представленны в виде массива numpy, далее для каждой найдена сумма весов и потом клики с суммами весов были отсортированы по сумме весов.
После сортировки применяется функция для поиска лучших групп(клик) с вхождением всех вершин. Как итог вместо >2млн строк в датафрейме получаем сразу 16 лучших на 80 вершинах.
Это сократило время выполнения с 8 минут до 1.5 минуты. </p>

<p> Следующим шагом было решено попробовать использовать метод библиотеки networkx get_edge_attributes упрощенного поиска ребер, что дало время выполнения в 50 секунд при 80 вершинах. </p>

<p> Последним шагом для оптимизации было урезание weight_threshold с -20 до -1 для уменьшения количества клик, так как клики с отрицательными весами нам для результата не нужны.
Это сократило время выполнения с 50 секунд до 30 секунд на 80 вершинах. </p>

<p> При попытке проверить работоспособность кода на 200 вершинах всплыло предупреждение о нехватке оперативной памяти для выполнения, что говорит о необходимости в больших вычислительных мощностях чем личный ноутбук.
На 100 вершинах код выполнялся 1.5 минуты. </p>

<p> Как итог, предполагается, что код будет отрабатывать в приемлемое время на больших вычистельных мощностях, так как используется параллельность(joblib.Parallel), которое использует по возможности максимально допустимое количество ядер процессора для параллельной обработки в цикле. </p>

<p> Если сравнивать networkx и graph_tool, нельзя не подметить удобство и обширность методов и готовых алгоритмов реализованных в networkx, что делает работу с этой библиотекой значительно проще. Что говоря о времени выполнения, то на данной задаче разницы во времени выполнения между networkx и graph_tool, если брать создание и заполнение графа, выявленно не было.
В остальном же с использованием методов networkx, которые отствуют в graph_tool, код с networkx выполнялся быстрее. </p>

